import assert from 'assert';
import {
  Expression,
  ExpressionStatement,
  ExternalReferenceType,
  FunctionCall,
  Identifier,
  Literal,
  LiteralKind,
  Return,
} from 'solc-typed-ast';
import { AST } from '../../ast/ast';
import { ASTMapper } from '../../ast/mapper';
import { cloneASTNode } from '../../utils/cloning';
import { createBoolLiteral } from '../../utils/nodeTemplates';
import { toHexString } from '../../utils/utils';

export class Require extends ASTMapper {
  // Function to add passes that should have been run before this pass
  addInitialPassPrerequisites(): void {
    const passKeys: Set<string> = new Set<string>([]);
    passKeys.forEach((key) => this.addPassPrerequisite(key));
  }

  visitExpressionStatement(node: ExpressionStatement, ast: AST): void {
    const expressionNode = node.vExpression;

    const cairoAssert = this.requireToCairoAssert(expressionNode, ast);
    if (cairoAssert === null) {
      this.commonVisit(node, ast);
      return;
    }

    // Since cairoAssert is not null, this is a require/revert/assert function call
    assert(expressionNode instanceof FunctionCall);

    ast.replaceNode(node, cairoAssert);
  }

  visitReturn(node: Return, ast: AST): void {
    const expressionNode = node.vExpression;
    const cairoAssert = this.requireToCairoAssert(expressionNode, ast);
    if (cairoAssert === null) return;

    ast.insertStatementBefore(node, cairoAssert);
    node.vExpression = undefined;
  }

  requireToCairoAssert(expression: Expression | undefined, ast: AST): ExpressionStatement | null {
    if (
      expression instanceof FunctionCall &&
      expression.vFunctionCallType === ExternalReferenceType.Builtin &&
      ['assert', 'require', 'revert'].includes(expression.vIdentifier)
    ) {
      // TODO: The identifier node generated by the solc-typed-ast has different typestrings
      //       and referencedDeclaration number for assert, require and revert Solidity functions.
      //       Check typestring when updating solc-typed-ast version.
      const assertIdentifier = cloneASTNode(expression.vExpression, ast);
      assert(assertIdentifier instanceof Identifier);
      assertIdentifier.name = 'assert';

      const args: Expression[] = [];
      if (expression.vIdentifier === 'revert') args.push(createBoolLiteral(false, ast));
      args.push(...expression.vArguments);
      if (args.length < 2) {
        const message = 'Assertion error';
        args.push(
          new Literal(
            ast.reserveId(),
            '',
            `literal_string "${message}"`,
            LiteralKind.String,
            toHexString(message),
            message,
          ),
        );
      }

      return new ExpressionStatement(
        ast.reserveId(),
        expression.src,
        new FunctionCall(
          ast.reserveId(),
          '',
          expression.typeString,
          expression.kind,
          assertIdentifier,
          args,
        ),
      );
    }

    return null;
  }
}
