from __future__ import annotations
from eth_hash.auto import keccak
from enum import Enum, auto
import os
import json

WARP_ROOT = os.path.abspath(os.path.join(__file__, "../../.."))


class ContractLang(Enum):
    SOL = 0
    VYPER = 2


def read_file_json(file_name: str) -> List[str]:
    with open(file_name) as f:
        data = f.readlines()
    abi = []
    for line in data:
        if not "[" in line:
            continue
        else:
            abi.extend(json.loads(line))
    return abi


def from_abi(file_name: str) -> List[str]:
    sigs = []
    data = read_file_json(file_name)
    for item in data:
        if item["type"] != "function":
            continue
        else:
            name = item["name"] + "("
            if len(item["inputs"]) == 0:
                name += ")"
                sigs.append(name)
                continue
            for idx, x in enumerate(item["inputs"]):
                if (idx == len(item["inputs"]) - 1) or item["inputs"] == "":
                    name += x["type"] + ")"
                else:
                    name += x["type"] + ","
            sigs.append(name)
    return sigs


def is_entry_seq(opcodes: List[str], language: ContractLang) -> bool:
    if language == ContractLang.SOL:
        return (
            opcodes[0] == "PUSH4"
            and opcodes[2] == "EQ"
            and opcodes[3] == "PUSH2"
            and opcodes[5] == "JUMPI"
            and opcodes[6] == "DUP1"
        )
    elif language == ContractLang.VYPER:
        return (
            opcodes[0] == "PUSH4"
            and opcodes[2] == "DUP2"
            and opcodes[3] == "EQ"
            and opcodes[4] == "ISZERO"
            and opcodes[5] == "PUSH2"
            and opcodes[7] == "JUMPI"
        )


def get_selectors(abi_file_path: str) -> Dict[str, str]:
    sigs = from_abi(abi_file_path)
    selectors = {}
    for sig in sigs:
        selector = "0x" + keccak(sig.encode("ascii")).hex()[:8]
        if "0" in selector[2:]:
            selector = "0x" + selector[2:].lstrip("0")
        selectors[selector] = sig
    return selectors


def get_language(filename):
    if filename.endswith("vy"):
        return ContractLang.VYPER
    elif filename.endswith("sol"):
        return ContractLang.SOL


def selector_jumpdest(
    selectors: Dict[str, str], opcodes_file: str
) -> Dict[str, Dict[str, int]]:
    selector_jumpdests = {}
    opcodes_path = opcodes_file
    language = ContractLang.VYPER
    with open(opcodes_path) as f:
        opcodes = f.readlines()
    # remove solidity / vyper comments auto-generated by the compiler
    ops_clean = ""
    for idx, op in enumerate(opcodes):
        # The compiler generates some comment lines, and
        # the opcodes are all in a single line and always start with a
        # PUSH instruction
        if op.startswith("PUSH"):
            ops_clean += op
    all_ops = ops_clean.replace("\n", "").split(" ")
    l = len(all_ops)
    idx = 0
    dest_pos = 4 + language._value_
    inc = 8
    while idx < l:
        if is_entry_seq(all_ops[idx : idx + 8], language):
            try:
                selector = all_ops[idx + 1].lower()
                func_sig = selectors[selector]
                selector_jumpdests[selector] = {func_sig: int(all_ops[idx + 6], 16)}
                idx += inc
                continue
            except KeyError:
                selector = all_ops[idx + 1].lower()
                print(selector)
                idx += inc
                continue
        idx += 1
    return selector_jumpdests


pth = os.path.join(WARP_ROOT, "tests", "utils", "yearn")
selectors = get_selectors(f"{pth}.abi")
#dests = selector_jumpdest(selectors, f"{pth}.opcode")
print(selectors)
#print(dests)
