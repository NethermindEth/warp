// SPDX-License-Identifier: LGPL-3.0-only
pragma solidity ^0.8.0;

/// @title StorageAccessible - generic base contract that allows callers to access all internal storage.
/// @notice See https://github.com/gnosis/util-contracts/blob/bb5fe5fb5df6d8400998094fb1b32a178a47c3a1/contracts/StorageAccessible.sol
contract StorageAccessible {
  /**
   * @dev Reads `length` bytes of storage in the currents contract
   * @param offset - the offset in the current contract's storage in words to start reading from
   * @param length - the number of words (32 bytes) of data to read
   * @return the bytes that were read.
   */
  function getStorageAt(uint256 offset, uint256 length)
    public
    view
    returns (bytes memory)
  {
    bytes memory result = new bytes(length * 32);
    for (uint256 index = 0; index < length; index++) {
      // solhint-disable-next-line no-inline-assembly
      assembly {
        let word := sload(add(offset, index))
        mstore(add(add(result, 0x20), mul(index, 0x20)), word)
      }
    }
    return result;
  }

  /**
   * @dev Performs a delegatecall on a targetContract in the context of self.
   * Internally reverts execution to avoid side effects (making it static).
   *
   * This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.
   * Specifically, the `returndata` after a call to this method will be:
   * `success:bool || response.length:uint256 || response:bytes`.
   *
   * @param targetContract Address of the contract containing the code to execute.
   * @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).
   */
  function simulateAndRevert(address targetContract, bytes memory calldataPayload)
    external
  {
    // solhint-disable-next-line no-inline-assembly
    assembly {
      let success := delegatecall(
        gas(),
        targetContract,
        add(calldataPayload, 0x20),
        mload(calldataPayload),
        0,
        0
      )

      mstore(0x00, success)
      mstore(0x20, returndatasize())
      returndatacopy(0x40, 0, returndatasize())
      revert(0, add(returndatasize(), 0x40))
    }
  }
}
