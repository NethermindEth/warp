---
title: Installation and Usage
---

## Installation

### Dependencies

1. You will need [z3](https://github.com/Z3Prover/z3) installed to use Warp.

- Install command on macOS:

```
brew install z3
```

- Install command on Ubuntu:

```
sudo apt install libz3-dev
```

2. Have Python 3.7 installed with the virtualenv ([`venv`](https://docs.python.org/3/library/venv.html)) module in your base env.

### Warp Installation Method 1

Without any virtual environment activated perform the following in order:

1. Add the warp package from npm.

```
yarn global add @nethermindeth/warp
```

2. Ensure the package was added by checking the version number:

```
warp version
```

3. Install the dependencies:

```
warp install
```

4. Test the installation worked by transpiling an example ERC20 contract:

```
warp transpile example_contracts/ERC20.sol
```

### Warp Installation Method 2 (from source/for devs)

Make sure you have the [dependencies](#dependencies) installed first.

With a virtual environment (recommended Python3.7) activated:

1. Clone this repo and change directory into the `warp` folder.

2. Install the JavaScript dependencies:

```
yarn
```

3. Install the Python dependencies:

```
pip install -r requirements.txt
```

If you are using a M1 chipped Mac and getting a `'gmp.h' file not found` error when installing Cairo run the following:

```
CFLAGS=-Ibrew --prefix gmp/include LDFLAGS=-Lbrew --prefix gmp/lib pip install ecdsa fastecdsa sympy
```

Then run the pip command above again.

4. Compile the project:

```
yarn tsc
yarn warplib
```

5. Test the installation worked by transpiling an example ERC20 contract:

```
bin/warp transpile example_contracts/ERC20.sol
```

## Usage

Warp 2 allows transpiling directly from Solidity to Cairo and transpiled .cairo file can be deployed to starknet.

### Transpiling

To transpile a solidity file, run:

```
warp transpile [PATH_TO_SOLIDITY_FILE]
```

For example:

```
warp transpile contracts/token/ERC20/ERC20.sol
```

The output of the transpilation could be found in warp_output folder.

Now the file can be compiled and deployed. Run the following to compile the Cairo contract:

```
warp compile warp_output/contracts/token/ERC20/ERC20__WARP_CONTRACT__ERC20.cairo
```

If we have solidity code as :

```
contract WARP {
  uint256 public counter;

  function increment() public returns (uint256) {
    counter += 1;
    return counter;
  }
}
```

The transpiled cairo file would look like this:

```
%lang starknet

from starkware.cairo.common.uint256 import Uint256
from starkware.cairo.common.cairo_builtins import HashBuiltin
from warplib.maths.add import warp_add256

func WS0_READ_Uint256{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr : felt}(
    loc : felt
) -> (val : Uint256):
    alloc_locals
    let (read0) = WARP_STORAGE.read(loc)
    let (read1) = WARP_STORAGE.read(loc + 1)
    return (Uint256(low=read0, high=read1))
end

func WS_WRITE0{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr : felt}(
    loc : felt, value : Uint256
) -> (res : Uint256):
    WARP_STORAGE.write(loc, value.low)
    WARP_STORAGE.write(loc + 1, value.high)
    return (value)
end

# Contract Def WARP

@storage_var
func WARP_STORAGE(index : felt) -> (val : felt):
end
@storage_var
func WARP_USED_STORAGE() -> (val : felt):
end
@storage_var
func WARP_NAMEGEN() -> (name : felt):
end
func readId{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr : felt}(
    loc : felt
) -> (val : felt):
    alloc_locals
    let (id) = WARP_STORAGE.read(loc)
    if id == 0:
        let (id) = WARP_NAMEGEN.read()
        WARP_NAMEGEN.write(id + 1)
        WARP_STORAGE.write(loc, id + 1)
        return (id + 1)
    else:
        return (id)
    end
end

namespace WARP:
    # Dynamic variables - Arrays and Maps

    # Static variables

    const __warp_usrid0_counter = 0

    @external
    func increment_d09de08a{
        syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr : felt
    }() -> (__warp_usrid1_ : Uint256):
        alloc_locals

        let (__warp_se_0) = WS0_READ_Uint256(__warp_usrid0_counter)

        let (__warp_se_1) = warp_add256(__warp_se_0, Uint256(low=1, high=0))

        WS_WRITE0(__warp_usrid0_counter, __warp_se_1)

        let (__warp_se_2) = WS0_READ_Uint256(__warp_usrid0_counter)

        return (__warp_se_2)
    end

    @view
    func counter_61bc221a{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr : felt}(
        ) -> (__warp_usrid2_ : Uint256):
        alloc_locals

        let (__warp_se_3) = WS0_READ_Uint256(__warp_usrid0_counter)

        return (__warp_se_3)
    end

    @constructor
    func constructor{syscall_ptr : felt*, pedersen_ptr : HashBuiltin*, range_check_ptr : felt}():
        alloc_locals
        WARP_USED_STORAGE.write(2)

        return ()
    end
end

# Original soldity abi: ["constructor()","increment()"]
```

### Deploying

```
warp deploy [PATH_TO_TRANSPILED_CAIRO_CONTRACT] --use_cairo_abi --inputs  [INPUT_ARGUMENTS]
```

For example:

```
warp deploy warp_output/contracts/token/ERC20/ERC20__WARP_CONTRACT__ERC20.cairo --use_cairo_abi --inputs  10,0x4e,0x45,0x54,0x48,0x45,0x52,0x43,0x4f,0x49,0x4e,4,0x4e,0x45,0x54,0x48
```

#### Note

In the example above, we needed a name and ticker for our ERC20 coin. We used NETHERCOIN and NETH. StarkNet does not support Solidity-style strings, so the Warp team treats them as dynamic arrays of bytes. To match the StarkNet abi we need to pass the length of the arrays and the value of each byte.
