---
title: ABI Encode
---

When transpiling solidity code which uses ABI encoding, cairo functions are generated to mimic this behaviour.
This functions returns a felt array where each element is between 0 and 255, a representation of Solidity's bytes array.

ABI Encoding and packed encoding on both solidity and warped contract will be similar except for addresses.
Due to cairo addresses being able to occupy the whole felt space and solidity's only being 160 bits (considerably smaller) creates
compatibility issues, such as:

- When ABI encoding:
  although each data type occupies 32 bytes slot, and a `felt` fits perfectly inside,
  an address encoded on a warped contract on StarkNet and later decoded on a L1 will
  cause a `revert` if the address is bigger than 20 bytes. If you wish to decode an address on L1
  you must substitute the address type for uint256 e.g `abi.decode(data, (address))` -> `abi.decode(data, (uint256))`

- When ABI packed encoding: instead of storing the cairo address inside 20 bytes and having a potential
  information lost, they are stored as 32 bytes. As a consequence, the packed encoding in a warped contract
  and the solidity contract will always differ if addresses are one of the included types.
